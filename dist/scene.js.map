{"version":3,"sources":["webpack://scene/webpack/universalModuleDefinition","webpack://scene/webpack/bootstrap","webpack://scene/./src/boundingBox.js","webpack://scene/./src/loadingPanel.js","webpack://scene/./src/scene.js","webpack://scene/external \"three\"","webpack://scene/external \"three/examples/jsm/controls/OrbitControls.js\"","webpack://scene/external \"three/examples/jsm/loaders/GLTFLoader.js\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAA+B;;AAE/B;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,OAAO,+BAA+B,iBAAiB;AACtE;AACA;AACA;AACA;;AAEA,6BAA6B,iDAAiB;AAC9C,6BAA6B,uDAAuB,GAAG,iBAAiB;AACxE,yBAAyB,kDAAkB,OAAO,mDAAmB;AACrE;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAe;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChEA;AAAA;AAAA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAO;AACd;AACA;AACA;AACA;;AAEA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,OAAO;AAC9B,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;AC/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;AAC8C;AACP;AAC5B;AACF;;AAEjC;AACP,IAAI,mEAAY;AAChB,IAAI,iEAAW;AACf;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACe;AACf,sBAAsB,2CAAW;AACjC;AACA;AACA,sBAAsB,2CAAW;;AAEjC,WAAW,8CAA8C;;AAEzD;AACA;AACA;AACA,8BAA8B,qDAAY;AAC1C,KAAK;AACL;AACA;;AAEA,2BAA2B,2CAAW;;AAEtC;AACA,yBAAyB,mDAAmB,EAAE,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAsB;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,uDAAuB;AAC9C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,0FAAa;AACtC;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,+BAA+B,gDAAgB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,gDAAgB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAsB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAkB;AACxC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,uDAAuB;AAChD,yBAAyB,uDAAuB,GAAG,gBAAgB;AACnE,eAAe,0CAAU;AACzB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,uBAAuB,mFAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,8BAA8B,oDAAoB;AAClD;AACA;AACA;AACA,+CAA+C,8BAA8B,EAAE;AAC/E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;;AAE9C,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;;AAEvE,mBAAmB,OAAO;AAC1B,gCAAgC,8CAAc;AAC9C;;AAEA;AACA,0BAA0B,iDAAiB;AAC3C,+BAA+B,0CAAU;AACzC;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mDAAmB;AAC5C,yBAAyB,uDAAuB,GAAG,oBAAoB,gDAAgB,CAAC;AACxF,sBAAsB,0CAAU;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,0BAA0B,+CAAe;AACzC,sBAAsB,6CAAa;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kDAAkD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC3eA,mD;;;;;;;;;;;ACAA,0F;;;;;;;;;;;ACAA,sF","file":"scene.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"three/examples/jsm/controls/OrbitControls.js\"), require(\"three/examples/jsm/loaders/GLTFLoader.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"three/examples/jsm/controls/OrbitControls.js\", \"three/examples/jsm/loaders/GLTFLoader.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scene\"] = factory(require(\"three\"), require(\"three/examples/jsm/controls/OrbitControls.js\"), require(\"three/examples/jsm/loaders/GLTFLoader.js\"));\n\telse\n\t\troot[\"scene\"] = factory(root[\"three\"], root[\"three/examples/jsm/controls/OrbitControls.js\"], root[\"three/examples/jsm/loaders/GLTFLoader.js\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_three__, __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_controls_OrbitControls_js__, __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_loaders_GLTFLoader_js__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/scene.js\");\n","import * as THREE from \"three\";\n\n/**\n * A bounding box that can be drawn in the scene.\n */\nexport default class BoundingBox {\n    /**\n     * Constructor.\n     * @param {Object} [params] Optional parameters {color, linewidth}.\n     */\n    constructor(params) {\n        const color = (params && params.color) ? params.color : 0x0000FF;\n        const linewidth = (params && params.lineWidth) ? params.lineWidth : 5;\n\n        const geometry = new THREE.BoxGeometry( 1,1,1 );\n        const material = new THREE.LineBasicMaterial( {color, linewidth} );\n        this._mesh = new THREE.LineSegments ( new THREE.EdgesGeometry(geometry), material );\n        this._bounds = null;\n        this._center = {x:0,y:0,z:0};\n    }\n\n    /**\n     * Updates the bounding box' size and position.\n     * @param object The object to bound.\n     */\n    update(object) {\n        const helper = new THREE.BoxHelper(object);\n        helper.geometry.computeBoundingBox();\n        this._bounds = helper.geometry.boundingBox;\n\n        const xSize = this._bounds.max.x - this._bounds.min.x;\n        const ySize = this._bounds.max.y - this._bounds.min.y;\n        const zSize = this._bounds.max.z - this._bounds.min.z;\n        this._center.x = this._bounds.min.x + xSize/2;\n        this._center.y = this._bounds.min.y + ySize/2;\n        this._center.z = this._bounds.min.z + zSize/2;\n\n        this._mesh.scale.set(xSize, ySize, zSize);\n        this._mesh.position.set(this._center.x,this._center.y,this._center.z);\n    }\n\n    /**\n     * Gets the mesh of the bounding box.\n     * @returns {LineSegments}\n     */\n    get mesh() {\n        return this._mesh;\n    }\n\n    /**\n     * Gets the bounds.\n     * @returns {Object}\n     */\n    get bounds() {\n        return this._bounds;\n    }\n\n    /**\n     * Gets the center of the bounding box.\n     * @returns {{x: number, y: number, z: number}}\n     */\n    get center() {\n        return this._center;\n    }\n}","/**\n * Dynamic generation of a simple loading window with a progress bar.\n * @param canvasID Optional canvas ID. If provided the loading window will be rendered inside the canvas DIV.\n * @returns {{onProgress: onProgress}} An onProgress function to pass to createScene().\n */\nexport default function LoadingPanel (canvasID) {\n    const prefix = canvasID ? canvasID + '_' : '';\n    generateCSS(canvasID, prefix);\n    generateHTML(canvasID, prefix);\n\n    /**\n     * Updates the progress info.\n     * @param progress Progress object from the scene generator.\n     */\n    function onProgress(progress) {\n        const progressPercentage = (progress.percentage * 100) + \"%\";\n\n        // Updates the progress bar.\n        const progressBar = document.getElementById( prefix + 'progressBarPercentage' );\n        progressBar.style.width = progressPercentage;\n\n        // Update the log panel.\n        const logPanel = document.getElementById( prefix + 'progressLogPanel' );\n        if (progress.errors.length > 0) {\n            logPanel.innerHTML = 'Failed to load some models.<br> See developer console for details.';\n            progressBar.style.backgroundColor = '#aa0000';\n        } else {\n            logPanel.innerHTML = 'Loaded: ' + progressPercentage;\n        }\n\n        // Hide after everything has been loaded.\n        if (progress.done) {\n            //console.log(progress);\n            const timeout = progress.errors.length === 0 ? 2000 : 5000;\n            setTimeout(() => {\n                document.getElementById(prefix + 'progressWindow').style.display = 'none';\n            }, timeout)\n        }\n    }\n\n    return {\n        onProgress: onProgress\n    };\n}\n\n/**\n * Generates the CSS for the loading panel.\n * @param canvasID Optional canvas ID.\n * @param prefix ID prefix.\n */\nfunction generateCSS(canvasID, prefix) {\n    const style = document.createElement('style');\n    //Deprecated: style.type = 'text/css';\n    let inner = '';\n    if (canvasID) {\n        inner += `\n        #${prefix}progressWindowOuterContainer {\n            box-sizing: border-box;\n            position: absolute;\n            overflow: visible;\n            width: 100%;\n            height: 0px;\n            margin: 0;\n            padding: 0;\n            z-index: 100000;\n        }\n        `;\n    } else {\n        inner += `\n        #${prefix}progressWindowOuterContainer {\n            box-sizing: border-box;\n            position: fixed;\n            overflow: visible;\n            width: 100%;\n            height: 0px;\n            margin: 0;\n            padding: 0;\n            z-index: 100000;\n        }\n        `;\n    }\n\n    inner += `\n    #${prefix}progressWindow {\n        box-sizing: border-box;\n        position: relative;\n        overflow: hidden;\n        width: 300px;\n        height: 130px;\n        top: 50px;\n        margin-left: auto;\n        margin-right: auto;\n        background-color: black;\n        color: white;\n        border: 1px solid #cccccc;\n        padding: 10px;\n    }\n    \n    #${prefix}progressWindowHeader {\n        box-sizing: border-box;\n        width: 100%;\n        margin-bottom: 10px;\n    }\n    \n    #${prefix}progressBar {\n        box-sizing: border-box;\n        width: 100%;\n        height: 16px;\n        background-color: #aaaaaa;\n        border: 1px solid #666666;\n        overflow: hidden;\n        margin-bottom: 10px;\n    }\n    \n    #${prefix}progressBarPercentage {\n        box-sizing: border-box;\n        width: 0%;\n        height: 14px;\n        background-color: #00ee00;\n        overflow: hidden;\n    }\n    \n    #${prefix}progressLogPanel {\n        box-sizing: border-box;\n        width: 100%;\n        height: 50px;\n        border: 1px solid #666666;\n        overflow: auto;\n        padding: 5px;\n        font-size: 12px;\n    }\n    `;\n    style.innerHTML = inner;\n    document.getElementsByTagName('head')[0].appendChild(style);\n}\n\n/**\n * Generates the HTML for the loading panel.\n * @param canvasID Optional canvas ID.\n * @param prefix ID prefix.\n */\nfunction generateHTML(canvasID, prefix) {\n    const div = document.createElement('div');\n    div.id = prefix + 'progressWindowOuterContainer';\n    div.innerHTML = `\n        <div id=\"${prefix}progressWindow\">\n            <div id=\"${prefix}progressWindowHeader\">Loading scene ...</div>\n            <div id=\"${prefix}progressBar\">\n                <div id=\"${prefix}progressBarPercentage\"></div>\n            </div>\n            <div id=\"${prefix}progressLogPanel\"></div>\n        </div>\n    `;\n    if (canvasID) {\n        document.getElementById(canvasID).appendChild(div);\n    } else {\n        document.getElementsByTagName('body')[0].appendChild(div);\n    }\n\n}\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport LoadingPanel from \"./loadingPanel\";\nimport BoundingBox from \"./boundingBox\";\n\nexport const utils = {\n    LoadingPanel,\n    BoundingBox\n};\n\n/**\n * Creates the scene.\n * @param {Object} config Scene configuration.\n * @param {Object} [params] Parameters.\n * @param {string} [params.canvasID] Optional canvas to render to.\n * @param {Function} [params.onProgress] Optional callback function to keep track of loading progress.\n * @param {Function} [params.onClick] Optional callback function to handle click events.\n * @param {boolean} [params.shadowsEnabled] Optional. True to calculate shadows.\n */\nexport default function createScene(config, params) {\n    const scene = new THREE.Scene();\n    // Mixers are used to animate GLTF meshes.\n    const mixers = [];\n    const clock = new THREE.Clock();\n\n    const {canvasID, onProgress, onClick, shadowsEnabled} = params;\n\n    // Determine if and how to show loading progress.\n    let progressHandler = null;\n    if (onProgress === undefined) {\n        progressHandler = new LoadingPanel(canvasID).onProgress\n    } else if (onProgress !== null) {\n        progressHandler = onProgress;\n    }\n\n    scene.background = new THREE.Color((config && config.backgroundColor) ? config.backgroundColor : 0xffffff );\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({antialias: true});\n    // Correct lightning. See: https://discourse.threejs.org/t/whats-this-about-gammafactor/4264/5\n    renderer.gammaOutput = true;\n    // Deprecated: renderer.gammaFactor = 2.2;\n    // Support shadows:\n    if (shadowsEnabled) {\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    }\n\n    let canvas, width, height;\n    if (canvasID) {\n        // Render to canvas (a DIV element with a certain size).\n        canvas = document.getElementById( canvasID );\n        canvas.appendChild( renderer.domElement );\n        width = canvas.clientWidth;\n        height = canvas.clientHeight;\n    } else {\n        // Render to body (full screen).\n        canvas = renderer.domElement;\n        width = window.innerWidth;\n        height = window.innerHeight;\n        document.body.appendChild(renderer.domElement);\n    }\n    renderer.setSize(width, height);\n\n    // Camera\n    const fov = config && config.camera && config.camera.fov ? config.camera.fov: 50;\n    const near = config && config.camera && config.camera.near ? config.camera.near: 0.1;\n    const far = config && config.camera && config.camera.far ? config.camera.far: 10000;\n\n    const camera = new THREE.PerspectiveCamera(fov, width / height, near, far);\n    if (config && config.camera && config.camera.position) {\n        camera.position.set(...config.camera.position);\n    } else {\n        camera.position.z = 30;\n    }\n\n    // Handle window resizes.\n    handleWindowResize(camera, renderer, canvasID);\n\n    // Enable controlling the camera with the mouse.\n    const controls = new OrbitControls(camera, canvas);\n    controls.target.set(0, 0, 0);\n\n    // Point lights\n    if (config && config.pointLights && config.pointLights.length > 0) {\n        config.pointLights.forEach(light => {\n            addPointLight(light, scene);\n        });\n    }\n\n    // Directional lights\n    if (config && config.directionalLights && config.directionalLights.length > 0) {\n        config.directionalLights.forEach(light => {\n            addDirectionalLight(light, scene);\n        });\n    } else {\n        addDirectionalLight(null, scene);\n    }\n\n    // Ambient light\n    addAmbientLight(config.ambientLight, scene);\n\n    // Load the models.\n    if (config && config.models && config.models.length > 0) {\n        let index = 0;\n        const totalProgress = {\n            percentage: 0,\n            errors: [],\n            done: false\n        }\n        config.models.forEach(model => {\n            loadModel(model, scene, mixers, index, progress => {\n                // Invoke progressHandler if provided.\n                if (progressHandler && (progressHandler instanceof Function)) {\n                    updateTotalProgress(model.file, config.models.length, progress, totalProgress);\n                    progressHandler(totalProgress);\n                }\n            });\n            index++;\n        })\n    } else {\n        scene.add(createBox());\n    }\n\n    // Add a skybox.\n    if (config && config.skybox) {\n        createSkybox(config.skybox, scene);\n    }\n\n    // Add the floor.\n    if (config && config.floor) {\n        addFloor(config.floor, scene);\n    }\n\n\n    // Add Axis system visualization\n    // Up: y (green), Right: x (red), Towards viewer: z (blue)\n    if (config && config.axis) {\n        const axesHelper = new THREE.AxesHelper(10);\n        scene.add(axesHelper);\n    }\n\n    // Click events\n    if (onClick && (onClick instanceof Function)) {\n        handleMouseClickEvents(renderer, width, height, camera, scene, onClick);\n    }\n\n    // Animate and render the scene.\n    const animate = function () {\n        requestAnimationFrame(animate);\n\n        // Update the animation if GLTF meshes.\n        const delta = clock.getDelta();\n        mixers.forEach(mixer => {\n            mixer.update( delta );\n        });\n\n        controls.update();\n        renderer.render(scene, camera);\n    };\n    animate();\n\n    return scene;\n}\n\n/**\n * Adds a point light.\n * @param {Object} light The light configuration.\n * @param scene The scene.\n */\nfunction addPointLight(light, scene) {\n    const color = light.color ? light.color : 0xFFFFFF;\n    const intensity = light.intensity ? light.intensity : 1;\n    const distance = light.distance ? light.distance : 2;\n\n    const lightInstance = new THREE.PointLight(color, intensity, distance);\n    lightInstance.position.set(...light.position);\n\n    // Shadows.\n    // Note: for this to work params.shadowsEnabled must be set to true in createScene.\n    lightInstance.castShadow = true;\n    // See: https://redstapler.co/threejs-realistic-light-shadow-tutorial/\n    lightInstance.shadow.bias = -0.0001;\n    lightInstance.shadow.mapSize.width = 1024*4;\n    lightInstance.shadow.mapSize.height = 1024*4;\n\n    scene.add( lightInstance );\n}\n\n/**\n * Adds a directional light to the scene.\n * @param {Object} light The light configuration.\n * @param scene The scene.\n */\nfunction addDirectionalLight(light, scene) {\n    const color = (light && light.color) ? light.color : 0xFFFFFF;\n    const intensity = (light && light.intensity) ? light.intensity : 1;\n    const lightInstance = new THREE.DirectionalLight(color, intensity);\n    if (light && light.position) {\n        lightInstance.position.set(...light.position);\n    } else {\n        lightInstance.position.set(150, 200, 130);\n    }\n    if (light && light.target) {\n        lightInstance.target.position.set(...light.target);\n    } else {\n        lightInstance.target.position.set(0, 0, 0);\n    }\n    // Shadows.\n    // Note: for this to work params.shadowsEnabled must be set to true in createScene.\n    lightInstance.castShadow = true;\n    // See: https://redstapler.co/threejs-realistic-light-shadow-tutorial/\n    lightInstance.shadow.bias = -0.0001;\n    lightInstance.shadow.mapSize.width = 1024*4;\n    lightInstance.shadow.mapSize.height = 1024*4;\n\n    scene.add(lightInstance);\n    scene.add(lightInstance.target);\n}\n\n/**\n * Adds ambient light to the scene.\n * @param {Object} ambientLight Ambient light configuration.\n * @param scene The scene.\n */\nfunction addAmbientLight(ambientLight, scene) {\n    const color = (ambientLight && ambientLight.color) ? ambientLight.color : 0xFFFFFF;\n    const intensity = (ambientLight && ambientLight.intensity) ? ambientLight.intensity : 0.5;\n    const light = new THREE.AmbientLight(color, intensity);\n    scene.add(light);\n}\n\n/**\n * Creates a box just for testing.\n * @returns {THREE.Mesh}\n */\nfunction createBox() {\n    const geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );\n    const material = new THREE.MeshPhongMaterial( {color: 0xeeeeee} );\n    return new THREE.Mesh( geometry, material );\n}\n\n/**\n * Loads a model.\n * @param {Object} model The model to load.\n * @param scene The scene.\n * @param {Array} mixers The array of mixers.\n * @param {number} index The model index.\n * @param {Function} cb Callback function to keep track of progress.\n */\nfunction loadModel(model, scene, mixers, index, cb) {\n    const loader = new GLTFLoader();\n    const progress = {\n        model: model.file,\n        index: index,\n        percentage: 0,\n        error: null\n    };\n    loader.load( model.file , function ( gltf ) {\n        // Position the model.\n        if (model.position) {\n            gltf.scene.position.set(...model.position);\n        }\n        // Scale the model.\n        if (model.scale) {\n            gltf.scene.scale.set(model.scale, model.scale, model.scale);\n        }\n        // Rotate the model.\n        // Yaw\n        if (model.rotateY) {\n            gltf.scene.rotateY(model.rotateY);\n        }\n        // Pitch\n        if (model.rotateX) {\n            gltf.scene.rotateX(model.rotateX);\n        }\n        // Roll\n        if (model.rotateZ) {\n            gltf.scene.rotateZ(model.rotateZ);\n        }\n\n        // Meta data. Needed for the onClick handler.\n        if (model.name) {\n            gltf.scene.name = model.name;\n        } else {\n            gltf.scene.name = model.file + \"_\" + index;\n        }\n        gltf.scene.userData = {\n            type: 'gltf',\n            clickable: model.clickable ? model.clickable : false,\n            file: model.file\n        }\n\n        // Corrections\n        // Metallic models appear very dark, so remove the metalness. Not sure if there is a better solution.\n        // See: https://discourse.threejs.org/t/ambient-light-and-gltf-models-not-working-results-in-black-model/7428/4\n        gltf.scene.traverse( child => {\n            if ( child.material ) child.material.metalness = 0;\n        });\n\n        // Shadows.\n        // Note: for this to work params.shadowsEnabled must be set to true in createScene.\n        gltf.scene.traverse(n => { if ( n.isMesh ) {\n            n.castShadow = model.castShadow !== undefined ? model.castShadow : true;\n            n.receiveShadow = model.receiveShadow !== undefined ? model.receiveShadow: true;\n            if(n.material.map) n.material.map.anisotropy = 16;\n        }});\n\n        // Add to the scene.\n        scene.add( gltf.scene );\n\n        // Animation\n        if (model.animate) {\n            const mixer = new THREE.AnimationMixer( gltf.scene );\n            mixers.push(mixer);\n            //const action = mixer.clipAction( gltf.animations[ 0 ] );\n            //action.play();\n            gltf.animations.forEach((clip) => {mixer.clipAction(clip).play(); });\n        }\n    }, function (xhr) {\n        progress.percentage = xhr.loaded / xhr.total;\n        if (cb) {\n            cb(progress);\n        }\n    },\n        function ( error ) {\n        // We set progress to 100% even though loading failed. So we know that this attempt was completed.\n        progress.percentage = 1;\n        progress.error = 'Failed to load model: ' + model.file;\n        console.error(progress.error);\n        if (cb) {\n            cb(progress);\n        }\n    });\n}\n\n/**\n * Updates to total progress of loading all the models.\n * @param modelFile The model file name of the models that is currently being loaded.\n * @param numberOfModels The total number of model to be loaded.\n * @param progress The progress of loading the current model (0 to 1)\n * @param totalProgress The total progress object to update.\n */\nfunction updateTotalProgress(modelFile, numberOfModels, progress, totalProgress) {\n    // Keeping track of the progress\n    if (!totalProgress.hasOwnProperty('_percentages')) {\n        totalProgress['_percentages'] = {};\n    }\n    totalProgress['_percentages'][progress.index] = progress.percentage;\n    let total = 0;\n    for (let index1 in totalProgress['_percentages']) {\n        if (totalProgress['_percentages'].hasOwnProperty(index1)) {\n            total += totalProgress['_percentages'][index1];\n        }\n    }\n    totalProgress.percentage = total / numberOfModels;\n\n    if (progress.error) {\n        totalProgress.errors.push(progress.error);\n    }\n\n    // If everything is loaded then we are done.\n    if (totalProgress.percentage === 1) {\n        totalProgress.done = true;\n    }\n}\n\n/**\n * Creates a skybox.\n * @param {Object} skybox Skybox configuration.\n * @param scene The scene.\n */\nfunction createSkybox(skybox, scene) {\n    const materialArray = [];\n    const folder = skybox.folder;\n    const texture_ft = new THREE.TextureLoader().load(folder + skybox.frontSide);\n    const texture_bk = new THREE.TextureLoader().load(folder + skybox.backSide);\n    const texture_up = new THREE.TextureLoader().load(folder + skybox.upSide);\n    const texture_dn = new THREE.TextureLoader().load(folder + skybox.downSide);\n    const texture_rt = new THREE.TextureLoader().load(folder + skybox.rightSide);\n    const texture_lf = new THREE.TextureLoader().load(folder + skybox.leftSide);\n\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));\n\n    for (let i = 0; i < 6; i++) {\n        materialArray[i].side = THREE.BackSide;\n    }\n\n    const size = skybox.size ? skybox.size : 10000;\n    const skyboxGeo = new THREE.BoxGeometry( size, size, size);\n    const skyboxInstance = new THREE.Mesh( skyboxGeo, materialArray );\n    scene.add( skyboxInstance );\n}\n\n/**\n * Adds a floor.\n * @param {Object} floor Floor configuration.\n * @param scene The scene.\n */\nfunction addFloor(floor, scene) {\n    const size = floor.size ? floor.size : 1000\n    const color = floor.color ? floor.color : 0x00FF00;\n    const level = floor.level ? floor.level : 0;\n\n    const geometry = new THREE.PlaneGeometry( size, size, 1, 1 );\n    const material = new THREE.MeshBasicMaterial( {color: color, side: THREE.DoubleSide} );\n    const plane = new THREE.Mesh( geometry, material );\n    plane.rotateX(0.5*Math.PI);\n    plane.position.set(0, level, 0);\n    scene.add( plane );\n}\n\n/**\n * Handles resizing of the browser window.\n * @param camera Camera.\n * @param renderer Renderer.\n * @param {String} canvasID Canvas ID.\n */\nfunction handleWindowResize(camera, renderer, canvasID) {\n    let width, height;\n    window.addEventListener( 'resize', onWindowResize, false );\n    function onWindowResize(){\n        if (canvasID) {\n            const canvas = document.getElementById( canvasID );\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        }\n        camera.aspect = width / height;\n        camera.updateProjectionMatrix();\n        renderer.setSize( width, height );\n    }\n}\n\n/**\n * Handles mouse click events as well as touch events.\n * @param {Object} renderer The renderer.\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param camera The camera.\n * @param scene The scene.\n * @param {Function} onClickCallback On click callback function.\n */\nfunction handleMouseClickEvents(renderer, width, height, camera, scene, onClickCallback) {\n    const rayCaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    const onClick = function(event) {\n        if (event.touches) {\n            // Touch event.\n            mouse.x = ( event.touches[0].clientX / width ) * 2 - 1;\n            mouse.y = - ( event.touches[0].clientY / height ) * 2 + 1;\n        } else {\n            // Mouse event.\n            mouse.x = ( event.clientX / width ) * 2 - 1;\n            mouse.y = - ( event.clientY / height ) * 2 + 1;\n        }\n        rayCaster.setFromCamera(mouse, camera);\n        const intersects = rayCaster.intersectObjects( scene.children, true );\n        let selectedObject = null;\n        for (let i=0; i<intersects.length; i++) {\n            let obj = intersects[i].object;\n            while (obj.parent !== null) {\n                obj = obj.parent;\n                if (obj.userData && obj.userData.type && (obj.userData.type === 'gltf') && (obj.userData.clickable)) {\n                    selectedObject = obj;\n                    if (onClickCallback) {\n                        onClickCallback({name: selectedObject.name, object: selectedObject});\n                    }\n                    break;\n                }\n            }\n            if (selectedObject) {\n                break;\n            }\n        }\n        if (!selectedObject) {\n            // Nothing was selected. Still call the callback to any previously selected object can be deselected.\n            onClickCallback({name: null, object: null});\n        }\n    }\n    // Register both mouse and touch events.\n    renderer.domElement.addEventListener('click', onClick, true);\n    renderer.domElement.addEventListener('touchstart', onClick, true);\n}","module.exports = __WEBPACK_EXTERNAL_MODULE_three__;","module.exports = __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_controls_OrbitControls_js__;","module.exports = __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_loaders_GLTFLoader_js__;"],"sourceRoot":""}