{"version":3,"sources":["webpack://scene/webpack/universalModuleDefinition","webpack://scene/webpack/bootstrap","webpack://scene/./src/scene.js","webpack://scene/external \"three\"","webpack://scene/external \"three/examples/jsm/controls/OrbitControls.js\"","webpack://scene/external \"three/examples/jsm/loaders/GLTFLoader.js\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;AAC8C;AACP;;AAEtE;AACA;AACA;AACe;AACf,sBAAsB,2CAAW;AACjC,2BAA2B,2CAAW;;AAEtC;AACA,yBAAyB,mDAAmB,EAAE,gBAAgB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,uDAAuB;AAC9C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,0FAAa;AACtC;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,+BAA+B,gDAAgB;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAsB;AACpD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAkB;AACxC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,uDAAuB;AAChD,yBAAyB,uDAAuB,GAAG,gBAAgB;AACnE,eAAe,0CAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;AAC9C,2BAA2B,mDAAmB;;AAE9C,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;AACvE,2BAA2B,uDAAuB,GAAG,kBAAkB;;AAEvE,mBAAmB,OAAO;AAC1B,gCAAgC,8CAAc;AAC9C;;AAEA;AACA,0BAA0B,iDAAiB;AAC3C,+BAA+B,0CAAU;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mDAAmB;AAC5C,yBAAyB,uDAAuB,GAAG,oBAAoB,gDAAgB,CAAC;AACxF,sBAAsB,0CAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC1PA,mD;;;;;;;;;;;ACAA,0F;;;;;;;;;;;ACAA,sF","file":"scene.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"three\"), require(\"three/examples/jsm/controls/OrbitControls.js\"), require(\"three/examples/jsm/loaders/GLTFLoader.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"three\", \"three/examples/jsm/controls/OrbitControls.js\", \"three/examples/jsm/loaders/GLTFLoader.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scene\"] = factory(require(\"three\"), require(\"three/examples/jsm/controls/OrbitControls.js\"), require(\"three/examples/jsm/loaders/GLTFLoader.js\"));\n\telse\n\t\troot[\"scene\"] = factory(root[\"three\"], root[\"three/examples/jsm/controls/OrbitControls.js\"], root[\"three/examples/jsm/loaders/GLTFLoader.js\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_three__, __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_controls_OrbitControls_js__, __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_loaders_GLTFLoader_js__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/scene.js\");\n","import * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\n\n/**\n * Creates the scene.\n */\nexport default function createScene(config) {\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color((config && config.backgroundColor) ? config.backgroundColor : 0xffffff );\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({antialias: true});\n\n    let canvas, width, height;\n    if (config && config.canvasID) {\n        // Render to canvas (a DIV element with a certain size).\n        canvas = document.getElementById( config.canvasID );\n        canvas.appendChild( renderer.domElement );\n        width = canvas.clientWidth;\n        height = canvas.clientHeight;\n    } else {\n        // Render to body (full screen).\n        canvas = renderer.domElement;\n        width = window.innerWidth;\n        height = window.innerHeight;\n        document.body.appendChild(renderer.domElement);\n    }\n    renderer.setSize(width, height);\n\n    // Camera\n    const fov = config && config.camera && config.camera.fov ? config.camera.fov: 50;\n    const near = config && config.camera && config.camera.near ? config.camera.near: 0.1;\n    const far = config && config.camera && config.camera.far ? config.camera.far: 10000;\n\n    const camera = new THREE.PerspectiveCamera(fov, width / height, near, far);\n    if (config && config.camera && config.camera.position) {\n        camera.position.set(...config.camera.position);\n    } else {\n        camera.position.z = 30;\n    }\n\n    // Handle window resizes.\n    handleWindowResize(config, camera, renderer);\n\n    // Enable controlling the camera with the mouse.\n    const controls = new OrbitControls(camera, canvas);\n    controls.target.set(0, 0, 0);\n\n    // Directional lights\n    if (config && config.directionalLights && config.directionalLights.length > 0) {\n        config.directionalLights.forEach(light => {\n            addDirectionalLight(light, scene);\n        })\n    } else {\n        addDirectionalLight(null, scene);\n    }\n\n    // Ambient light\n    addAmbientLight(config.ambientLight, scene);\n\n    // Load the models.\n    if (config && config.models && config.models.length > 0) {\n        config.models.forEach(model => {\n            loadModel(model, scene);\n        })\n    } else {\n        scene.add(createBox());\n    }\n\n    // Add a skybox.\n    if (config && config.skybox) {\n        createSkybox(config.skybox, scene);\n    }\n\n    // Add the floor.\n    if (config && config.floor) {\n        addFloor(config.floor, scene);\n    }\n\n\n    // Add Axis system visualization\n    // Up: y (green), Right: x (red), Towards viewer: z (blue)\n    if (config && config.axis) {\n        const axesHelper = new THREE.AxesHelper(10);\n        scene.add(axesHelper);\n    }\n\n    // Animate and render the scene.\n    const animate = function () {\n        requestAnimationFrame(animate);\n\n        controls.update();\n        renderer.render(scene, camera);\n    };\n    animate();\n}\n\n/**\n * Adds a directional light to the scene.\n * @param light The light configuration.\n * @param scene The scene.\n */\nfunction addDirectionalLight(light, scene) {\n    const color = (light && light.color) ? light.color : 0xFFFFFF;\n    const intensity = (light && light.intensity) ? light.intensity : 1;\n    const lightInstance = new THREE.DirectionalLight(color, intensity);\n    if (light && light.position) {\n        lightInstance.position.set(...light.position);\n    } else {\n        lightInstance.position.set(150, 200, 130);\n    }\n    if (light && light.target) {\n        lightInstance.target.position.set(...light.target);\n    } else {\n        lightInstance.target.position.set(0, 0, 0);\n    }\n    scene.add(lightInstance);\n    scene.add(lightInstance.target);\n}\n\n/**\n * Adds ambient light to the scene.\n * @param ambientLight Ambient light configuration.\n * @param scene The scene.\n */\nfunction addAmbientLight(ambientLight, scene) {\n    const color = (ambientLight && ambientLight.color) ? ambientLight.color : 0xFFFFFF;\n    const intensity = (ambientLight && ambientLight.intensity) ? ambientLight.intensity : 0.5;\n    const light = new THREE.AmbientLight(color, intensity);\n    scene.add(light);\n}\n\n/**\n * Creates a box just for testing.\n * @returns {THREE.Mesh}\n */\nfunction createBox() {\n    const geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );\n    const material = new THREE.MeshPhongMaterial( {color: 0xeeeeee} );\n    return new THREE.Mesh( geometry, material );\n}\n\n/**\n * Loads a model.\n * @param model The model to load.\n * @param scene The scene.\n */\nfunction loadModel(model, scene) {\n    const loader = new GLTFLoader();\n    loader.load( model.file , function ( gltf ) {\n        // Position the model.\n        if (model.position) {\n            gltf.scene.position.set(...model.position);\n        }\n        // Scale the model.\n        if (model.scale) {\n            gltf.scene.scale.set(model.scale, model.scale, model.scale);\n        }\n        // Rotate the model.\n        // Yaw\n        if (model.rotateY) {\n            gltf.scene.rotateY(model.rotateY);\n        }\n        // Pitch\n        if (model.rotateX) {\n            gltf.scene.rotateX(model.rotateX);\n        }\n        // Roll\n        if (model.rotateZ) {\n            gltf.scene.rotateZ(model.rotateZ);\n        }\n\n        // Add to the scene.\n        scene.add( gltf.scene );\n    }, undefined, function ( error ) {\n        console.error( error );\n    } );\n}\n\n/**\n * Creates a skybox.\n * @param skybox Skybox configuration.\n * @param scene The scene.\n */\nfunction createSkybox(skybox, scene) {\n    const materialArray = [];\n    const folder = skybox.folder;\n    const texture_ft = new THREE.TextureLoader().load(folder + skybox.frontSide);\n    const texture_bk = new THREE.TextureLoader().load(folder + skybox.backSide);\n    const texture_up = new THREE.TextureLoader().load(folder + skybox.upSide);\n    const texture_dn = new THREE.TextureLoader().load(folder + skybox.downSide);\n    const texture_rt = new THREE.TextureLoader().load(folder + skybox.rightSide);\n    const texture_lf = new THREE.TextureLoader().load(folder + skybox.leftSide);\n\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));\n    materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));\n\n    for (let i = 0; i < 6; i++) {\n        materialArray[i].side = THREE.BackSide;\n    }\n\n    const size = skybox.size ? skybox.size : 10000;\n    const skyboxGeo = new THREE.BoxGeometry( size, size, size);\n    const skyboxInstance = new THREE.Mesh( skyboxGeo, materialArray );\n    scene.add( skyboxInstance );\n}\n\n/**\n * Adds a floor.\n * @param floor Floor configuration.\n * @param scene The scene.\n */\nfunction addFloor(floor, scene) {\n    const size = floor.size ? floor.size : 1000\n    const color = floor.color ? floor.color : 0x00FF00;\n\n    const geometry = new THREE.PlaneGeometry( size, size, 1, 1 );\n    const material = new THREE.MeshBasicMaterial( {color: color, side: THREE.DoubleSide} );\n    const plane = new THREE.Mesh( geometry, material );\n    plane.rotateX(0.5*Math.PI);\n    scene.add( plane );\n}\n\n/**\n * Handles resizing of the browser window.\n * @param config Configuration.\n * @param camera Camera.\n * @param renderer Renderer.\n */\nfunction handleWindowResize(config, camera, renderer) {\n    let width, height;\n    window.addEventListener( 'resize', onWindowResize, false );\n    function onWindowResize(){\n        if (config && config.canvasID) {\n            const canvas = document.getElementById( config.canvasID );\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        }\n        camera.aspect = width / height;\n        camera.updateProjectionMatrix();\n        renderer.setSize( width, height );\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE_three__;","module.exports = __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_controls_OrbitControls_js__;","module.exports = __WEBPACK_EXTERNAL_MODULE_three_examples_jsm_loaders_GLTFLoader_js__;"],"sourceRoot":""}